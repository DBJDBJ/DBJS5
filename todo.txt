
dbj approach is/was to completely encapsualte any possible complexity of
comparing all possible thing in es5 in al possible ways.

But:: There is a different approach in design. First keep core imp as simple as possible:

/*simplest*/cond = function (v) {
    var j = 1, L = arguments.length;
    for (; j < L; j += 2) {
        if (v === arguments[j]) return arguments[j + 1];
    }
    return (!arguments[j - 2]) ? undefined : arguments[j - 2];
}

Simply leave the core cond() implementation as simple as possible.
Use "===" as the only comparator.
But! Then imagine and example with boolean value as an in-value (aka first argument)

var x =4;
cond(true,x<2,"green",x<7,"red","defaultclr");

This opens up the way to use any kind of comparator user wants without original 
complex dbj.cond() implementation!

For example we can use dbj.EQ.rathe() , the core powerfull comparator of anything, with 
the simple cond:

cond ( true, dbj.EQ.rathe([1,2,3],[1,2,3]), "OK", "default") ; // returns "OK"

a more generic example:

var inp = [1,2,3], comp = dbj.EQ.rathe, check = [1,2,3], resval = "OK", defval = "default" ;

cond( true, comp(inp, check), resval, defval ) ;

Why is this not good?
1. lower level of encapsulation
1.1 forces users to understand and use proper comparators (true, for complex jobs only)

Is this good and why is this good? 

1. simpler code and simpler usage patterns
1.1 simple is more resilient code
2. comparator vs call context is cleaner vs. current dbj.cond applicator
3. greater decoupling between comparators and cond. 
3.1. which means easy(er) change of the comparator's
3.2 this even opens a way to have cond() in native code, still with replaceable comparators!
3.3 if cond() is in a native code then we might have JS with no if's and no switch-es !

dbj MUST implement ASAP cond() as an nodes.js extension // 2013JUL10

**************************************
LISP ref text on condition-als
http://www.gnu.org/software/emacs/manual/html_node/elisp/Conditionals.html
**************************************
cond chooses among an arbitrary number of alternatives. Each clause in the cond must be a list. The car of this list is the condition; the remaining elements, if any, the body-forms. Thus, a clause looks like this:

          (condition body-forms...)
cond tries the clauses in textual order, by evaluating the condition of each clause. If the value of condition is non-nil, the clause “succeeds”; then cond evaluates its body-forms, and the value of the last of body-forms becomes the value of the cond. The remaining clauses are ignored.

If the value of condition is nil, the clause “fails”, so the cond moves on to the following clause, trying its condition.

If every condition evaluates to nil, so that every clause fails, cond returns nil.

A clause may also look like this:

          (condition)
Then, if condition is non-nil when tested, the value of condition becomes the value of the cond form.

The following example has four clauses, which test for the cases where the value of x is a number, string, buffer and symbol, respectively:

          (cond ((numberp x) x)
                ((stringp x) x)
                ((bufferp x)
                 (setq temporary-hack x) ; multiple body-forms
                 (buffer-name x))        ; in one clause
                ((symbolp x) (symbol-value x)))
Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use t as the condition of the last clause, like this: (t body-forms). The form t evaluates to t, which is never nil, so this clause never fails, provided the cond gets to it at all. For example:

          (setq a 5)
          (cond ((eq a 'hack) 'foo)
                (t "default"))
          ⇒ "default"
This cond expression returns foo if the value of a is hack, and returns the string "default" otherwise.

Any conditional construct can be expressed with cond or with if. Therefore, the choice between them is a matter of style. For example:

     (if a b c)
     ==
     (cond (a b) (t c))
**************************************
Of course dbj cond is way more maleable to JS programmers. I especially dislike the way default is implemented
in LISP (cond ...). Why is not the last argument simply an default outcome ?
Like this:
     (if a b c)
     ==
     (cond (a b) c)
Why is the 't' needed ? dbj cond in LISP will be notated like so:

(dbjcond a (b c) (d e) f)

or concrete example

(setq a 1)
(dbjcond a (1 "one") (2 "two2) "default") ==> "one"

above in standard lisp cond will be:

(seqt a 1)
(cond ((eq a 1) "one") ((eq a 2) "two") (t "default") ) ==> "one"
